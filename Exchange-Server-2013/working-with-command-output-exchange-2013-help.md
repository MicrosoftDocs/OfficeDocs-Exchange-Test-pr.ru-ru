---
title: 'Работа с выходными данными команды: Exchange 2013 Help'
TOCTitle: Работа с выходными данными команды
ms:assetid: 8320e1a5-d3f5-4615-878d-b23e2aaa6b1e
ms:mtpsurl: https://technet.microsoft.com/ru-ru/library/Bb123533(v=EXCHG.150)
ms:contentKeyID: 50488484
ms.date: 05/22/2018
mtps_version: v=EXCHG.150
ms.translationtype: MT
---

# Работа с выходными данными команды

 

_**Применимо к:** Exchange Server 2013_

_**Последнее изменение раздела:** 2015-03-09_

В командной консоли Exchange предложено несколько методов форматирования выходных данных команды. В этом разделе обсуждаются следующие темы:

  - How to format data   Управление форматированием отображаемых данных с помощью командлетов **Format-List**, **Format-Table** и **Format-Wide**.

  - How to output data   Указание на необходимость выводить данные в окно командной консоли или в файл с помощью командлетов **Out-Host** и **Out-File**. В этом разделе также приведен пример сценария для вывода данных в Майкрософт Internet Explorer.

  - How to filter data   Фильтрация данных осуществляется с помощью одного из следующих методов фильтрации:
    
      - Фильтрация на стороне сервера, доступная в некоторых командлетах
    
      - Фильтрация на стороне клиента, доступная во всех командлетах при конвейерной передаче результатов выполнения команды в командлет **Where-Object**

Чтобы использовать функциональные возможности, описанные в этом разделе, необходимо ознакомиться со следующими разделами:

  - [Конвейеризация](https://technet.microsoft.com/ru-ru/library/aa998260\(v=exchg.150\))

  - [Переменные командной консоли](https://technet.microsoft.com/ru-ru/library/bb124036\(v=exchg.150\))

  - [Операторы сравнения](https://technet.microsoft.com/ru-ru/library/bb125229\(v=exchg.150\))

## Форматирование данных

Если в конце конвейерной передачи вызываются командлеты форматирования, можно переопределить форматирование по умолчанию, чтобы управлять составом данных и способом их отображения. Командлетами форматирования являются командлеты **Format-List**, **Format-Table** и **Format-Wide**. У каждого командлета имеется особый стиль вывода, отличающийся от стилей других командлетов форматирования.

## Format-List

Командлет **Format-List** принимает данные по конвейеру и отображает список с вертикальными столбцами, в который включены все указанные свойства каждого объекта. С помощью параметра *Property* можно указать, какие свойства следует отображать. Если командлет **Format-List** был вызван без указанных параметров, возвращаются все свойства. Командлет **Format-List** переносит строки, а не усекает их. Одно из лучших применений командлета **Format-List** — это переопределение способа отображения данных по умолчанию для получения дополнительных или более точных сведений.

Например, при вызове командлета **Get-Mailbox** будет отображаться только ограниченное количество сведений в виде таблицы. Если передать по конвейеру данные, возвращаемые командлетом **Get-Mailbox**, в командлет **Format-List** и добавить параметры для отображения дополнительных или более точных сведений, можно получить необходимые данные.

Также можно указать подстановочный знак \* с частью имени свойства. Если используется подстановочный знак, можно подбирать несколько свойств без необходимости ввода имени каждого свойства. Например, командлет `Get-Mailbox | Format-List -Property Email* ` возвращает все свойства, которые начинаются с `Email`.

В следующих примерах показаны различные способы просмотра одних и тех же данных, возвращаемых командлетом **Get-Mailbox**.

```powershell
Get-Mailbox TestUser1
    
Name                      Alias                ServerName       ProhibitSendQuo
                                                                ta
----                      -----                ----------       ---------------
TestUser1                 TestUser1            mbx              unlimited
```
В первом примере командлет **Get-Mailbox** вызывается без определенного форматирования, так что выходные данные по умолчанию будут отображаться в виде таблицы и содержать предварительно определенный набор свойств.

```powershell
Get-Mailbox TestUser1 | Format-List -Property Name,Alias,EmailAddresses
    
Name           : TestUser1
Alias          : TestUser1
EmailAddresses : {SMTP:TestUser1@contoso.com}
```

Во втором примере выходные данные командлета **Get-Mailbox** передаются по конвейеру в командлет **Format-List** вместе с определенными свойствами. Как видно в этом примере, форматирование и содержимое выходных данных заметно отличается от предыдущего примера.

```powershell
Get-Mailbox TestUser1 | Format-List -Property Name, Alias, Email*
Name                      : Test User
Alias                     : TestUser1
EmailAddresses            : {SMTP:TestUser1@contoso.com}
EmailAddressPolicyEnabled : True
```

В последнем примере выходные данные командлета **Get-Mailbox** направляются в командлет **Format-List**, как и во втором примере. Однако в последнем примере подстановочный знак используется для нахождения всех свойств, которые начинаются с `Email`.

Если в командлет **Format-List** передается несколько объектов, отображаются все указанные для объектов свойства, сгруппированные по объектам. Порядок отображения зависит от параметра командлета по умолчанию. Параметр *Name* или *Identity* наиболее часто является параметром по умолчанию. Например, если вызывается командлет **Get-Childitem**, порядком отображения по умолчанию будет являться список имен файлов в алфавитном порядке. Чтобы изменить такое поведение, необходимо вызвать командлет **Format-List**, указав параметр *GroupBy* и имя значения свойства, по которому следует сгруппировать возвращаемые данные. Например, с помощью следующей команды можно отобразить список всех файлов в каталоге и сгруппировать их по расширениям.

```powershell
    Get-Childitem | Format-List Name,Length -GroupBy Extension
    
        Extension: .xml
    
    Name   : Config_01.xml
    Length : 5627
    
    Name   : Config_02.xml
    Length : 3901
    
    
        Extension: .bmp
    
    Name   : Image_01.bmp
    Length : 746550
    
    Name   : Image_02.bmp
    Length : 746550
    
    
        Extension: .txt
    
    Name   : Text_01.txt
    Length : 16822
    
    Name   : Text_02.txt
    Length : 9835
```
В этом примере командлет **Format-List** группирует элементы по свойству *Extension*, которое указано в параметре *GroupBy*. В потоке передачи по конвейеру можно использовать параметр *GroupBy* с любым допустимым свойством объектов.

## Format-Table

Командлет **Format-Table** позволяет отображать элементы в виде таблицы с заголовками и столбцами данных свойств. По умолчанию многие командлеты, например: **Get-Process** и **Get-Service**, используют формат таблицы для отображения возвращаемых данных. Параметры командлета **Format-Table** содержат параметры *Properties* и *GroupBy*. Они имеют те же функции, что и аналогичные параметры командлета **Format-List**.

В командлете **Format-Table** также используется параметр *Wrap*. При задании этого параметра включается полное отображение свойств вместо усечения каждого конца строки. Чтобы посмотреть, как отображаются возвращаемые данные, обработанные с помощью параметра *Wrap*, сравните выходные данные команды **Get-Command** в следующих двух примерах.

В первом примере командлет **Get-Command** используется для отображения сведений о командлете **Get-Process**; данные в свойстве *Definition* усекаются.

```powershell
    Get-Command Get-Process | Format-Table Name,Definition
    
    Name                                    Definition
    ----                                    ----------
    get-process                             get-process [[-ProcessName] String[]...
```

Во втором примере в команду добавляется параметр *Wrap* для принудительного отображения всего содержимого свойства *Definition*.

```powershell
    Get-Command Get-Process | Format-Table Name,Definition -Wrap
    
    Get-Process                             Get-Process [[-Name] <String[]>] [-Comp
                                            uterName <String[]>] [-Module] [-FileVe
                                            rsionInfo] [-Verbose] [-Debug] [-ErrorA
                                            ction <ActionPreference>] [-WarningActi
                                            on <ActionPreference>] [-ErrorVariable
                                            <String>] [-WarningVariable <String>] [
                                            -OutVariable <String>] [-OutBuffer <Int
                                            32>]
                                            Get-Process -Id <Int32[]> [-ComputerNam
                                            e <String[]>] [-Module] [-FileVersionIn
                                            fo] [-Verbose] [-Debug] [-ErrorAction <
                                            ActionPreference>] [-WarningAction <Act
                                            ionPreference>] [-ErrorVariable <String
                                            >] [-WarningVariable <String>] [-OutVar
                                            iable <String>] [-OutBuffer <Int32>]
                                            Get-Process [-ComputerName <String[]>]
                                            [-Module] [-FileVersionInfo] -InputObje
                                            ct <Process[]> [-Verbose] [-Debug] [-Er
                                            rorAction <ActionPreference>] [-Warning
                                            Action <ActionPreference>] [-ErrorVaria
                                            ble <String>] [-WarningVariable <String
                                            >] [-OutVariable <String>] [-OutBuffer
                                            <Int32>]
```

Как и в командлете **Format-List**, можно указать подстановочный знак `*` с частью имени свойства. Если используется подстановочный знак, можно отбирать различные свойства без необходимости ввода имени каждого свойства.

## Format-Wide

С помощью командлета **Format-Wide** обеспечивается более простое управление выходными данными по сравнению с другими командлетами форматирования. По умолчанию командлет **Format-Wide** пытается отобразить по возможности как можно большее количество столбцов значений свойств в строке вывода. С помощью добавляемых параметров можно управлять количеством столбцов и использованием свободного места в отображаемых данных.

Основной способ применения — это вызов командлета **Format-Wide** без параметров, что приведет к отображению такого количества столбцов, какое сможет уместиться на странице. Например, если выполняется командлет **Get-Childitem** и его данные передаются по конвейеру в командлет **Format-Wide**, будет отображено следующее:

```powershell
    Get-ChildItem | Format-Wide
    
        Directory: FileSystem::C:\WorkingFolder
    
    Config_01.xml                           Config_02.xml
    Config_03.xml                           Config_04.xml
    Config_05.xml                           Config_06.xml
    Config_07.xml                           Config_08.xml
    Config_09.xml                           Image_01.bmp
    Image_02.bmp                            Image_03.bmp
    Image_04.bmp                            Image_05.bmp
    Image_06.bmp                            Text_01.txt
    Text_02.txt                             Text_03.txt
    Text_04.txt                             Text_05.txt
    Text_06.txt                             Text_07.txt
    Text_08.txt                             Text_09.txt
    Text_10.txt                             Text_11.txt
    Text_12.txt
```

Как правило, вызов командлета **Get-Childitem** без параметров приведет к отображению имен всех файлов в каталоге в таблице свойств. В этом примере выходные данные, передаваемые по конвейеру из командлета **Get-Childitem** в командлет **Format-Wide**, были отображены в двух столбцах с именами. Заметьте, что единовременно может быть отображен только один тип свойств, указанный именем свойства, которое следует за командлетом **Format-Wide**. Если добавить параметр *Autosize*, отображение данных изменится с двух столбцов на то их количество, которое может уместиться по ширине экрана.

```powershell
    Get-ChildItem | Format-Wide -AutoSize
    
        Directory: FileSystem::C:\WorkingFolder
    
    Config_01.xml   Config_02.xml   Config_03.xml   Config_04.xml   Config_05.xml
    Config_06.xml   Config_07.xml   Config_08.xml   Config_09.xml   Image_01.bmp
    Image_02.bmp    Image_03.bmp    Image_04.bmp    Image_05.bmp    Image_06.bmp
    Text_01.txt     Text_02.txt     Text_03.txt     Text_04.txt     Text_05.txt
    Text_06.txt     Text_07.txt     Text_08.txt     Text_09.txt     Text_10.txt
    Text_11.txt     Text_12.txt
```

В этом примере таблица разбита на пять столбцов вместо двух. С помощью параметра *Column* можно достичь более точного управления путем определения максимального количества столбцов для отображения данных, например:

```powershell
    Get-ChildItem | Format-Wide -Column 4
    
        Directory: FileSystem::C:\WorkingFolder
    
    Config_01.xml       Config_02.xml       Config_03.xml       Config_04.xml
    Config_05.xml       Config_06.xml       Config_07.xml       Config_08.xml
    Config_09.xml       Image_01.bmp        Image_02.bmp        Image_03.bmp
    Image_04.bmp        Image_05.bmp        Image_06.bmp        Text_01.txt
    Text_02.txt         Text_03.txt         Text_04.txt         Text_05.txt
    Text_06.txt         Text_07.txt         Text_08.txt         Text_09.txt
    Text_10.txt         Text_11.txt         Text_12.txt
```

В этом примере с помощью параметра *Column* было принудительно задано количество столбцов, равное четырем.

## Вывод данных

## Командлеты Out-Host и Out-File

Командлет **Out-Host** является скрытым командлетом по умолчанию, используемым в конце передачи по конвейеру. После применения форматирования командлет **Out-Host** отправляет последние выходные данные в окно консоли для их отображения. Нет необходимости явно вызывать командлет **Out-Host**, так как это делается по умолчанию. Можно переопределить отправку выходных данных в окно консоли с помощью командлета **Out-File**, поставив его последним командлетом в команде. Затем командлет **Out-File** записывает выходные данные в файл, который указывается пользователем в команде, как показано в следующем примере:

```powershell
Get-ChildItem | Format-Wide -Column 4 | Out-File c:\OutputFile.txt
```

В этом примере командлет **Out-File** записывает данные, отображенные в команде **Get-ChildItem | Format-Wide -Column 4**, в файл с именем `OutputFile.txt`. Также можно перенаправить выходные данные в файл с помощью оператора перенаправления — правой угловой скобки ( `>` ). Чтобы добавить выходные данные конвейерной передачи команды в существующий файл без замены исходного файла, используйте двойные правые угловые скобки ( `>>` ), как показано в следующем примере.

```powershell
Get-ChildItem | Format-Wide -Column 4 >> C:\OutputFile.txt
```

В этом примере выходные данные командлета **Get-Childitem** передаются по конвейеру в командлет **Format-Wide** для форматирования, а затем дозаписываются в файл `OutputFile.txt`. Заметьте, что если файл `OutputFile.txt` не существует, то использование двойных правых угловых скобок ( `>>` ) приведет к созданию файла.

Дополнительные сведения о конвейерной передаче см. в разделе [Конвейеризация](https://technet.microsoft.com/ru-ru/library/aa998260\(v=exchg.150\)).

Дополнительные сведения о синтаксисе, использованном в предыдущих примерах, см. в разделе [Синтаксис](https://technet.microsoft.com/ru-ru/library/bb123552\(v=exchg.150\)).

## Просмотр данных в браузере Internet Explorer

Вследствие гибкости и простоты создания сценариев в командной консоли Exchange, можно форматировать данные, возвращаемые командами, и отображать их всеми различными способами.

В следующем примере показано, как можно использовать простой сценарий для обработки данных, возвращаемых командой, и отображения их в браузере Internet Explorer. В этом сценарии используются объекты, переданные по конвейеру, открывается окно браузера Internet Explorer, а затем в Internet Explorer отображаются данные:

   ```powershell
    $Ie = New-Object -Com InternetExplorer.Application
    $Ie.Navigate("about:blank")
    While ($Ie.Busy) { Sleep 1 }
    $Ie.Visible = $True
    $Ie.Document.Write("$Input")
    # If the previous line doesn't work on your system, uncomment the line below.
    # $Ie.Document.IHtmlDocument2_Write("$Input")
    $Ie
   ```

Чтобы использовать этот сценарий, сохраните его в каталоге `C:\Program Files\Microsoft\Exchange Server\V15\Scripts` на компьютере, где следует выполнить этот сценарий. Назовите этот файл `Out-Ie.ps1`. После сохранения файла можно использовать этот сценарий как стандартный командлет.

> [!NOTE]  
> Для запуска сценариев в Exchange 2013 они должны быть добавлены в роль управления с незаданной областью, а пользователю должна быть назначена роль управления напрямую или с помощью группы ролей управления. Дополнительные сведения см. в разделе <a href="understanding-management-roles-exchange-2013-help.md">Общие сведения о ролях управления</a>.


Условием использования сценария `Out-Ie` является получение данных в допустимом формате HTML. Чтобы преобразовать просматриваемые данные в формат HTML, необходимо передать результаты выполнения команды по конвейеру в командлет **ConvertTo-Html**. Затем можно передать результаты этой команды в сценарий `Out-Ie`. В следующем примере показано, как просматривать список каталогов в окне Internet Explorer:

```powershell
Get-ChildItem | Select Name,Length | ConvertTo-Html | Out-Ie
```

## Фильтрация данных

Командная консоль предоставляет доступ к большому количеству сведений о серверах, почтовых ящиках, службе каталогов Active Directory и других объектах в организации. Несмотря на то что доступ к этим сведениям способствует лучшему представлению о среде, эти большие объемы сведений могут поставить пользователя в затруднительное положение. С помощью командной консоли можно управлять этими сведениями и получать только необходимые данные с помощью фильтров. Доступны следующие два типа фильтрации:

  - **Фильтрация на стороне сервера**   Использование этой фильтрации заключается в том, что можно указать фильтр в командной строке и передать его на опрашиваемый сервер Exchange. Сервер обрабатывает запрос и возвращает только те данные, которые соответствуют указанному фильтру.
    
    Фильтрация на стороне сервера выполняется только с теми объектами, которые могут вернуть десятки или сотни тысяч результатов. Поэтому только командлеты управления получателями (например, командлет **Get-Mailbox**) и командлеты управления очередями (например, командлет **Get-Queue**) поддерживают фильтрацию на стороне сервера. Эти командлеты поддерживают параметр *Filter*. Этот параметр использует указанное выражение фильтра и передает его на сервер для обработки.

  - **Фильтрация на стороне клиента**   Эта фильтрация выполняется над объектами в текущем окне локальной консоли. При использовании этой фильтрации командлет получает в окне локальной консоли все объекты, которые соответствуют выполняемой задаче. Затем в командной консоли используются все возвращенные результаты, к ним применяется фильтр на стороне клиента и возвращаются только те результаты, которые соответствуют фильтру. Фильтрацию на стороне клиента поддерживают все командлеты. Эту фильтрацию можно выполнить путем конвейерной передачи результатов команды в командлет **Where-Object**.

## Фильтрация на стороне сервера

Реализация фильтрации на стороне сервера зависит от поддерживающего ее командлета. Фильтрация на стороне сервера включена только для особых свойств возвращаемых объектов. Для получения дополнительной информации обратитесь к справке для следующих командлетов:


<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
</colgroup>
<tbody>
<tr class="odd">
<td><p>Get-ActiveSyncDevice</p></td>
<td><p>Get-ActiveSyncDeviceClass</p></td>
<td><p>Get-CASMailbox</p></td>
<td><p>Get-Contact</p></td>
<td><p>Get-DistributionGroup</p></td>
</tr>
<tr class="even">
<td><p>Get-DynamicDistributionGroup</p></td>
<td><p>Get-Group</p></td>
<td><p>Get-Mailbox</p></td>
<td><p>Get-MailboxStatistics</p></td>
<td><p>Get-MailContact</p></td>
</tr>
<tr class="odd">
<td><p>Get-MailPublicFolder</p></td>
<td><p>Get-MailUser</p></td>
<td><p>Get-Message</p></td>
<td><p>Get-MobileDevice</p></td>
<td><p>Get-Queue</p></td>
</tr>
<tr class="even">
<td><p>Get-QueueDigest</p></td>
<td><p>Get-Recipient</p></td>
<td><p>Get-RemoteMailbox</p></td>
<td><p>Get-RoleGroup</p></td>
<td><p>Get-SecurityPrincipal</p></td>
</tr>
<tr class="odd">
<td><p>Get-StoreUsageStatistics</p></td>
<td><p>Get-UMMailbox</p></td>
<td><p>Get-User</p></td>
<td><p>Get-UserPhoto</p></td>
<td><p>Remove-Message</p></td>
</tr>
<tr class="even">
<td><p>Resume-Message</p></td>
<td><p>Resume-Queue</p></td>
<td><p>Retry-Queue</p></td>
<td><p>Suspend-Message</p></td>
<td><p>Suspend-Queue</p></td>
</tr>
</tbody>
</table>


## Фильтрация на стороне клиента

Фильтрация на стороне клиента может использоваться с любым командлетом. Эта функция включает командлеты, которые также поддерживают фильтрацию на стороне сервера. Как было описано выше, в фильтрации на стороне клиента можно использовать все данные, возвращенные предыдущей командой при передаче по конвейеру. В свою очередь, эта фильтрация возвращает результаты, которые соответствуют заданному фильтру. Эта фильтрация выполняется командлетом **Where-Object**. В сокращенной форме он выглядит как **Where**.

В процессе передачи по конвейеру командлет **Where** получает данные от предыдущего объекта, затем фильтрует данные перед их направлением к следующему объекту. Фильтрация основана на блоке сценария, который определен в команде **Where**. Этот блок сценария фильтрует данные, основываясь на свойствах и значениях объектов.

Командлет **Clear-Host** используется для очистки окна консоли. В этом примере можно найти все определенные псевдонимы для командлета **Clear-Host**, если будет выполнена следующая команда:

```powershell
    Get-Alias | Where {$_.Definition -eq "Clear-Host"}
    
    CommandType     Name                            Definition
    -----------     ----                            ----------
    Alias           clear                           clear-host
    Alias           cls                             clear-host
```

Командлет **Get-Alias** и команда **Where** взаимодействуют, чтобы возвратить список псевдонимов, которые были определены исключительно для командлета **Clear-Host**. В следующей таблице показан каждый элемент команды **Where**, который используется в этом примере.

### Элементы команды Where

<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>Элемент</th>
<th>Описание</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p><code>{ }</code></p></td>
<td><p>Фигурные скобки ограничивают блок сценария, в котором определен фильтр.</p></td>
</tr>
<tr class="even">
<td><p><code>$_</code></p></td>
<td><p>С помощью этой специальной переменной можно автоматически инициировать и связать объекты в конвейере.</p></td>
</tr>
<tr class="odd">
<td><p><code>Definition</code></p></td>
<td><p>Свойство <code>Definition</code> является свойством текущих объектов для передачи по конвейеру, в котором хранится имя определения псевдонима. При использовании <code>Definition</code> с переменной <code>$_</code> имени свойства предшествует точка.</p></td>
</tr>
<tr class="even">
<td><p><code>-eq</code></p></td>
<td><p>Этот оператор сравнения &quot;равно&quot; используется для указания на то, что результат должен точно соответствовать значению свойства, представленному в выражении.</p></td>
</tr>
<tr class="odd">
<td><p>&quot;<strong>Clear-Host</strong>&quot;</p></td>
<td><p>В этом примере &quot;<strong>Clear-Host</strong>&quot; является значением для анализа команды.</p></td>
</tr>
</tbody>
</table>


В этом примере объекты, возвращенные командлетом **Get-Alias**, представляют все определенные псевдонимы в системе. Даже если они не видны из командной строки, псевдонимы собираются и передаются в командлет **Where** по конвейеру. Командлет **Where** использует сведения в блоке сценария для применения фильтра к объектам псевдонимов.

Специальная переменная `$`\_ представляет передаваемые объекты. Переменная `$_` автоматически инициализируется командной консолью и привязывается к текущему объекту конвейера. Дополнительные сведения об этой специальной переменной см. в разделе [Переменные командной консоли](https://technet.microsoft.com/ru-ru/library/bb124036\(v=exchg.150\)).

С помощью стандартного формата с точкой (объект.свойство) добавляется свойство `Definition` для определения точного свойства оцениваемого объекта. Затем с помощью оператора сравнения `-eq` сопоставляется значение этого свойства с `"Clear-Host"`. Для отображения в окне консоли передаются только те объекты, которые имеют свойство `Definition`, соответствующее указанному критерию. Дополнительные сведения об операторах сравнения см. в разделе [Операторы сравнения](https://technet.microsoft.com/ru-ru/library/bb125229\(v=exchg.150\)).

После завершения фильтрации командой **Where** объектов, возвращенных командлетом **Get-Alias**, отфильтрованные объекты затем могут быть переданы по конвейеру в другую команду. Следующая команда обрабатывает только отфильтрованные объекты, возвращенные командой Where.

